package org.domino.engine.utility.log.openlog;import lotus.domino.AgentContext;import lotus.domino.Database;import lotus.domino.DateTime;import lotus.domino.Document;import lotus.domino.NotesException;import lotus.domino.NotesFactory;import lotus.domino.RichTextItem;import lotus.domino.Session;import java.util.*;import java.io.*;public class OpenLogItem {	/*	 * =======================================================	 * <HEADER>	 * NAME:	OpenLogClass script library	 * VERSION:	20070321a	 * AUTHOR(S):	Julian Robichaux ( http://www.nsftools.com )	 * ORIGINAL SOURCE:	The OpenLog database, available as an	 * open-source project at http://www.OpenNTF.org	 * HISTORY:	 * 20070321a:	Added startTime global to mark when this particular agent	 * 					run began, so you can group multiple errors/events	 * 					together more easily (see the "by Database and	 * 					Start Time" view)	 * 20060314a:	fixed bug where logErrorEx would set the message to	 * 					the severity type instead of the value of msg.	 * 20041111a:	made SEVERITY_ and TYPE_ constants public.	 * 20040928a:	added callingMethodDepth variable, which should be	 *					incremented by one in the Synchronized class so we'll	 *					get a proper reference to the calling method; make 	 *					$PublicAccess = "1" when we create new log docs, so	 *					users with Depositor access to this database can still	 *					create log docs.	 * 20040226a:	removed synchronization from all methods in the main	 *					OpenLogItem class and added the new	 *					SynchronizedOpenLogItem class, which simply extends	 *					OpenLogItem and calls all the public methods as 	 *					synchronized methods. Added olDebugLevel and	 *					debugOut public members to report on internal errors.	 * 20040223a:	add variables for user name, effective user name,	 * 					access level, user roles, and client version;	 * 					synchronized most of the public methods.	 * 20040222a:	this version got a lot less aggressive with the Notes	 * 					object recycling, due to potential problems. Also	 * 					made LogErrorEx and LogEvent return "" if an error 	 * 					occurred (to be consistent with LogError); added 	 * 					OpenLogItem(Session s) constructor; now get server 	 * 					name from the Session object, not the AgentContext 	 * 					object (due to differences in what those two things will 	 * 					give you); add UseDefaultLogDb and UseCustomLogDb 	 * 					methods; added getLogDatabase method, to be 	 * 					consistent with LotusScript functions; added	 * 					useServerLogWhenLocal and logToCurrentDatabase	 * 					variables/options	 * 20040217a:	this version made the agentContext object global	 * 					and fixed a problem where the agentContext was	 * 					being recycled in the constuctor (this is very bad)	 * 20040214b:	initial version	 *	 * 	 *   Copyright 2004-2009, Julian Robichaux	 *	 *   Licensed under the Apache License, Version 2.0 (the "License");	 *   you may not use this file except in compliance with the License.	 *   You may obtain a copy of the License at	 *	 *       http://www.apache.org/licenses/LICENSE-2.0	 *	 *   Unless required by applicable law or agreed to in writing, software	 *   distributed under the License is distributed on an "AS IS" BASIS,	 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.	 *   See the License for the specific language governing permissions and	 *   limitations under the License.	 *	 * </HEADER>	 * =======================================================	 * 	 * This class contains generic functions that can be used to log events and errors	 * to the OpenLog database. All you have to do it copy this script library to any	 * database that should be sending errors to the OpenLog database, and add it	 * to your Java agents using the Edit Project button (see the "Using This Database"	 * doc in the OpenLog database for more details).	 *	 * At the beginning of your agent, create a global instance of this class like this:	 *	 * private OpenLogItem oli = new OpenLogItem();	 *	 * and then in all the try/catch blocks that you want to send errors from, add the line:	 *	 * oli.logError(e);	 *	 * where "e" is the Exception that you caught. That's all you have to do. The LogError 	 * method will automatically create a document in the OpenLog database that contains 	 * all sorts of information about the error that occurred, including the name of the agent 	 * and function/sub that it occurred in.	 * 	 * For additional functionality, you can use the LogErrorEx function to add a custom	 * message, a severity level, and/or a link to a NotesDocument to the log doc.	 * 	 * In addition, you can use the LogEvent function to add a notification document to	 * the OpenLog database.	 * 	 * You'll notice that I trap and discard almost all of the Exceptions that may occur as	 * the methods in this class are running. This is because the class is normally only used	 * when an error is occurring anyway, so there's not sense in trying to pass any new	 * errors back up the stack.	 *	 * The master copy of this script library resides in the OpenLog database. 	 * All copies of this library in other databases should be set to inherit changes from 	 * that database.	 */	 	 // common severity types	public static final String SEVERITY_LOW = "0";	public static final String SEVERITY_MEDIUM = "1";	public static final String SEVERITY_HIGH = "2";		// common event types	public static final String TYPE_ERROR = "Error";	public static final String TYPE_EVENT = "Event";		// private members	private String thisDatabase;	private String thisServer;	private String thisAgent;	private Vector stackTrace;	private Session session;	private AgentContext agentContext;	private Database logDb;	private Database currentDatabase;	private boolean dbInitiated = false;	private boolean logSuccess = true;	private String userName;	private String effName;	private String accessLevel;	private Vector userRoles;	private Vector clientVersion;	private DateTime startTime;			// MODIFY THESE FOR YOUR OWN ENVIRONMENT	// (don't forget to use double-backslashes if this database	// is in a Windows subdirectory -- like "logs\\OpenLog.nsf")	private String logDbName = "StdPublic\\OpenLog.nsf";	private String logFormName = "LogEvent";		// public members (so I don't have to write a million Get/Set methods)	public String formName;	public int errNum;	public int errLine;	public String errMsg;	public String methodName;	public String severity;	public DateTime eventTime;	public String eventType;	public String message;	public Document errDoc;		// a few options that the user can set (because these are public	// members, you can override the global settings on a case-by-case	// basis in your agents):		// when this is true, the agent will attempt to write errors to the	// default OpenLog database on the server that this database	// is on, when the agent is run from the local workstation	public boolean useServerLogWhenLocal = true;		// when this is true, the agent will attempt to write errors to the	// database that we're currently using, instead of to a separate	// log database. If this is true, logging will be done to this database,	// regardless of the setting of useServerLogWhenLocal. This	// should always be set to false if you're not using this class within	// the confines of a Notes agent.	public boolean logToCurrentDatabase = false;		// this variable sets the "debug level" of all the methods. Right now	// the valid debug levels are:	// 	0 -- internal errors are discarded 	// 	1 -- Exception messages from internal errors are printed	// 	2 -- stack traces from internal errors are also printed	public int olDebugLevel = 0;		// debugOut is the PrintStream that errors will be printed to, for debug levels	// greater than 1 (System.err by default)	public PrintStream debugOut = System.err;		// this is a strange little variable we use to determine how far down the stack	// the calling method should be (see the getBasicLogFields method if you're	// curious)	protected int callingMethodDepth = 2;		/*	 * Use this constructor when you're creating an instance of the class	 * within the confines of an Agent. It will automatically pick up the agent	 * name, the current database, and the server.	 */	public OpenLogItem () {		this(null);	}			/*	 * Use this constructor when you're creating an instance of the class	 * with your own Session object (in some cases this can be more efficient)	 */	public OpenLogItem (Session s) {		try {			if (s == null) {				session = NotesFactory.createSession();			} else {				session = s;			}			thisServer = session.getServerName();			if (thisServer == null)				thisServer = "";						userName = session.getUserName();			clientVersion = new Vector();			String cver = session.getNotesVersion();			if (cver != null) {				if (cver.indexOf("|") > 0) {					clientVersion.addElement(cver.substring(0, cver.indexOf("|")));					clientVersion.addElement(cver.substring(cver.indexOf("|") + 1));				} else {					clientVersion.addElement(cver);				}			}						agentContext = session.getAgentContext();			if (agentContext != null) {				thisDatabase = agentContext.getCurrentDatabase().getFilePath();				thisAgent = agentContext.getCurrentAgent().getName();				currentDatabase = agentContext.getCurrentDatabase();				thisServer = currentDatabase.getServer();				effName = agentContext.getEffectiveUserName();				userRoles = session.evaluate("@UserRoles");				switch (currentDatabase.getCurrentAccessLevel()) {					case 0 : accessLevel = "0: No Access"; break;					case 1 : accessLevel = "1: Depositor"; break;					case 2 : accessLevel = "2: Reader"; break;					case 3 : accessLevel = "3: Author"; break;					case 4 : accessLevel = "4: Editor"; break;					case 5 : accessLevel = "5: Designer"; break;					case 6 : accessLevel = "6: Manager"; break;				}			}						startTime = session.createDateTime("Today");			startTime.setNow();						resetFields();		} catch(Exception e) {			debugPrint(e);		}	}			/*	 * Use this constuctor when you're creating an instance of the class	 * in anything that's not an agent (like a servlet). You can choose 	 * descriptive names for the database and the agent, so the errors and	 * events will be categorized in a meaningful way in the log database	 * (for example, for a servlet you may want to use "Servlet" as the	 * dbName, and the servlet name as the agentName).	 */	public OpenLogItem (String dbName, String agentName) {		try {			thisDatabase = dbName;			thisAgent = agentName;			session = NotesFactory.createSession();			thisServer = session.getServerName();			if (thisServer == null)				thisServer = "";						userName = session.getUserName();			clientVersion = new Vector();			String cver = session.getNotesVersion();			if (cver != null) {				if (cver.indexOf("|") > 0) {					clientVersion.addElement(cver.substring(0, cver.indexOf("|")));					clientVersion.addElement(cver.substring(cver.indexOf("|") + 1));				} else {					clientVersion.addElement(cver);				}			}						startTime = session.createDateTime("Today");			startTime.setNow();						resetFields();		} catch(Exception e) {			debugPrint(e);		}	}			/*	 * We can't really safely recycle() any of the global Notes objects, because	 * there's no guarantee that nothing else is using them. Instead, just set	 * everything to null	 */	public void recycle () {		errDoc = null;		logDb = null;		agentContext = null;		session = null;	}			/*	 * This gets called automatically when the object is destroyed.	 */	 protected void finalize () throws Throwable {	 	recycle();	 	super.finalize();	 }	 	 	 /*	  * see what the status of the last logging event was	  */	public boolean getLogSuccess () {		return logSuccess;	}			/*	 * reset all the global fields to their default values	 */	public void resetFields () {		try {			formName = logFormName;			errNum = 0;			errLine = 0;			errMsg = "";			methodName = "";			stackTrace = null;			severity = SEVERITY_LOW;			eventType = TYPE_ERROR;			message = "";			errDoc = null;		} catch(Exception e) {			debugPrint(e);		}	}			/*	 * Initialize the Database object that connects to the OpenLog database.	 * We don't do this when the class is constructed because there's a chance	 * that we'll never have to log anything to the database, in which case we'd	 * be wasting time and resources finding the database and connecting to it	 * right away. However, I made the method public in case you disagree with	 * this logic, so you can initialize the global object whenever you want to.	 */	public void initLogDb () {		// if we've already tried doing this once, don't bother trying again;		// either we were able to connect to the database and we've already		//got a handle to it, or we failed and we'd keep on failing		if (!dbInitiated)			useDefaultLogDb();	}			/*	 * Get a handle to the current log database that we're using. If it hasn't been	 * initiated yet, try to connect to it first using the useDefaultLogDb method	 */	public Database getLogDatabase () {		if (!dbInitiated)			useDefaultLogDb();		return logDb;	}			/*	 * Use the default log database to write our errors to (based on the values set	 * in the useServerLogWhenLocal and logToCurrentDatabase variables). This	 * method will nullify and set the logDb variable as well.	 *	 * Normally, you should never need to call this method, because it gets called	 * automatically the first time you log an event or an error. The two times you 	 * might want it are:	 *	 * 1.  If you want to connect to the log database early in your agent or thread,	 * so you won't get the small time lag for connecting to the database when the	 * first error or event occurs (you could also call initLogDb in this case, although	 * this method returns a boolean value indicating whether the database connection	 * was successful, and initLogDb returns void).	 * 	 * 2. if you were previously sending log messages to a different database from	 * a calling to the useCustomLogDb method.	 */	public boolean useDefaultLogDb () {		try {			logDb = null;			if (logToCurrentDatabase) {				logDb = currentDatabase;			} else if ((!session.isOnServer()) && (useServerLogWhenLocal)) {				logDb = session.getDatabase(currentDatabase.getServer(), logDbName);			} else {				logDb = session.getDatabase(null, logDbName);			}		} catch(Exception e) {			debugPrint(e);		} finally {			dbInitiated = true;		}				return !(logDb == null);	}			/*	 * Send all errors and events to the Database of your choice, instead of	 * the default OpenLog database. After you've called this method once,	 * all further errors and events that are processed by this instance of the	 * class will be sent to this database (so you don't have to call it before	 * every call to LogError or LogEvent).	 */	public boolean useCustomLogDb (Database customDb) {		try {			logDb = null;			logDb = customDb;		} catch(Exception e) {			debugPrint(e);		} finally {			dbInitiated = true;		}				return !(logDb == null);	}			/*	 * The basic method you can use to log an error. Just pass the Exception	 * that you caught and this method collects information and saves it to the	 * OpenLog database.	 */	public String logError (Throwable ee) {		try {			resetFields();			getBasicLogFields(callingMethodDepth);			getErrorLogFields(ee);						message = errMsg;			severity = SEVERITY_LOW;			eventType = TYPE_ERROR;						initLogDb();			logSuccess = writeToLog(logDb);			return message;					} catch(Exception e) {			debugPrint(e);			logSuccess = false;			return "";		}	}			/*	 * A slightly more flexible way to send an error to the OpenLog database.	 * This allows you to include a message string (which gets added to the	 * log document just before the stack trace), a severity type (normally one	 * of the standard severity types within this class: OpenLogItem.SEVERITY_LOW, 	 * OpenLogItem.SEVERITY_MEDIUM, or OpenLogItem.SEVERITY_HIGH),	 * and/or a Document that may have something to do with the error (in which	 * case a DocLink to that Document will be added to the log document).	 */	public String logErrorEx (Throwable ee, String msg, String severityType, Document doc) {		try {			resetFields();			getBasicLogFields(callingMethodDepth);			getErrorLogFields(ee);						message = (msg == null ? "" : msg);			if (message.length() == 0)				message = errMsg;						severity = (severityType == null ? "" : severityType);			eventType = TYPE_ERROR;			errDoc = doc;						initLogDb();			logSuccess = writeToLog(logDb);			return message;					} catch(Exception e) {			debugPrint(e);			logSuccess = false;			return "";		}	}			/*	 * This method allows you to log an Event to the OpenLog database.	 * You should include a message describing the event, a severity type 	 * (normally one of the standard severity types within this class: 	 * OpenLogItem.SEVERITY_LOW,  OpenLogItem.SEVERITY_MEDIUM, 	 * or OpenLogItem.SEVERITY_HIGH), and optionally  a Document that 	 * may have something to do with the event (in which case a DocLink to 	 * that Document will be added to the log document).	 */	public String logEvent (String msg, String severityType, Document doc) {		try {			resetFields();			getBasicLogFields(callingMethodDepth);						message = msg;			severity = (severityType == null ? "" : severityType);			eventType = TYPE_EVENT;			errDoc = doc;						initLogDb();			logSuccess = writeToLog(logDb);			return message;					} catch(Exception e) {			debugPrint(e);			logSuccess = false;			return "";		}	}			/*	 * A helper method that gets some basic information for the global	 * variables that's common to all errors and events (event time and	 * the name of the calling method).	 * 	 * The stacklevel parameter probably looks a little mysterious. It's	 * supposed to be the number of levels below the calling method	 * that we're at right now, so we know how far down the stack trace	 * we need to look to get the name of the calling method. For example,	 * if another method called the logError method, and the logError	 * method called this method, then the calling method is going to be	 * 2 levels down the stack, so stacklevel should be = 2. That may not	 * make sense to anyone but me, but it seems to work...	 */	private boolean getBasicLogFields (int stacklevel) {		try {			try {				Throwable ee = new Throwable("whatever");				stackTrace = getStackTrace(ee, stacklevel + 1);				//stackTrace = getStackTrace(ee);			} catch(Exception e) {			}						if (eventTime == null)				eventTime = session.createDateTime("Today");			eventTime.setNow();						methodName = getMethodName(stackTrace, 0);						return true;		} catch(Exception e) {			debugPrint(e);			return false;		}	}			/*	 * If an Exception is a NotesException, this method will extract the	 * Notes error number and error message.	 */	private boolean getErrorLogFields (Throwable ee) {		try {			stackTrace = getStackTrace(ee);			errLine = getMethodErrorLine(stackTrace, methodName);			try {				if (ee instanceof NotesException) {					NotesException ne = (NotesException)ee;					errNum = ne.id;					errMsg = ne.text;				} else {					errMsg = stackTrace.elementAt(0).toString();				}			} catch (Exception e) {				errMsg = "";			}						return true;		} catch (Exception e) {			debugPrint(e);			return false;		}	}			/*	 * Get the stack trace of an Exception as a Vector, without the	 * initial error message, and skipping over a given number of items	 * (as determined by the skip variable)	 */	private Vector getStackTrace (Throwable ee, int skip) {		Vector v = new Vector(32);		try {			StringWriter sw = new StringWriter();			ee.printStackTrace(new PrintWriter(sw));			StringTokenizer st = new StringTokenizer(sw.toString(), "\n");			int count = 0;			while (st.hasMoreTokens()) {				if (skip <= count++)					v.addElement(st.nextToken().trim());				else					st.nextToken();			}					} catch (Exception e) {			debugPrint(e);		}				return v;	}		private Vector getStackTrace (Throwable ee) {		return getStackTrace(ee, 0);	}			/*	 * Given the name of a method in a stack trace, this will parse the	 * stack trace and attempt to extract the line number in that method	 * that was referenced in the trace, assuming the normal format of	 * a stack trace, such as:	 * 		java.lang.NumberFormatException: notanumber	 * 			at java.lang.Integer.parseInt(Integer.java:335)	 * 			JavaAgent.NotesMain(JavaAgent.java:15) 	 * 			...	 */	private int getMethodErrorLine (Vector trace, String methodName) {		try {			String s = getMethodReference(trace, methodName);			String ls = s.substring(s.lastIndexOf(":") + 1);			ls = ls.substring(0, ls.indexOf(")"));			return Integer.parseInt(ls);		} catch (Exception e) {			debugPrint(e);			return 0;		}	}			/*	 * Attempt to get the name of the method referenced a certain number	 * of lines (linenum) down the stack trace, assuming the normal format	 * of a stack trace, such as:	 * 		java.lang.NumberFormatException: notanumber	 * 			at java.lang.Integer.parseInt(Integer.java:335)	 * 			JavaAgent.NotesMain(JavaAgent.java:15) 	 * 			...	 */	private String getMethodName (Vector trace, int linenum) {		try {			String s = getMethodReference(trace, linenum);			String ms = s.substring(s.indexOf(" ") + 1);			ms = ms.substring(0, ms.indexOf("("));			return ms;		} catch (Exception e) {			debugPrint(e);			return "";		}	}			/*	 * Get the line of text referenced a certain number of lines (linenum)	 * down the stack trace. This corresponds to the weird stackLevel	 * variable I use in the getBasicLogFields method.	 */	private String getMethodReference (Vector trace, int linenum) {		try {			return trace.elementAt(linenum).toString();		} catch (Exception e) {			debugPrint(e);			return "";		}	}			/*	 * Find the first line of text in a stack trace that contains a given	 * method name	 */	private String getMethodReference (Vector trace, String methodName) {		try {			if (methodName.length() == 0)				return "";						int i = 0;			for (i = 0; i < trace.size(); i++) {				if (trace.elementAt(i).toString().indexOf(methodName) >= 0)					break;			}						return trace.elementAt(i).toString();		} catch (Exception e) {			debugPrint(e);			return "";		}	}			/*	 * This is the method that does the actual logging to the OpenLog	 * database. You'll notice that I actually have a Database parameter,	 * which is normally a reference to the OpenLog database that you're	 * using. However, it occurred to me that you might want to use this	 * class to write to an alternate log database at times, so I left you	 * that option (although you're stuck with the field names used by the	 * OpenLog database in that case).	 *	 * This method creates a document in the log database, populates	 * the fields of that document with the values in our global variables,	 * and adds some associated information about any Document that	 * needs to be referenced. If you do decide to send log information to	 * an alternate database, you can just call this method manually after 	 * you've called logError or logEvent, and it will write everything to the	 * database of your choice.	 */	public boolean writeToLog (Database db) {		// exit early if there is no database		if (db == null)			return false;				boolean retval = false;		Document logDoc = null;		RichTextItem rtitem = null;		Database docDb = null;				try {			logDoc = db.createDocument();						logDoc.appendItemValue("Form", formName);			logDoc.appendItemValue("LogErrorNumber", errNum);			logDoc.appendItemValue("LogErrorLine", errLine);			logDoc.appendItemValue("LogErrorMessage", errMsg);			logDoc.appendItemValue("LogStackTrace", stackTrace);			logDoc.appendItemValue("LogSeverity", severity);			logDoc.appendItemValue("LogEventTime", eventTime);			logDoc.appendItemValue("LogEventType", eventType);			logDoc.appendItemValue("LogMessage", message);			logDoc.appendItemValue("LogFromDatabase", thisDatabase);			logDoc.appendItemValue("LogFromServer", thisServer);			logDoc.appendItemValue("LogFromAgent", thisAgent);			logDoc.appendItemValue("LogFromMethod", methodName);			logDoc.appendItemValue("LogAgentLanguage", "Java");			logDoc.appendItemValue("LogUserName", userName);			logDoc.appendItemValue("LogEffectiveName", effName);			logDoc.appendItemValue("LogAccessLevel", accessLevel);			logDoc.appendItemValue("LogUserRoles", userRoles);			logDoc.appendItemValue("LogClientVersion", clientVersion);			logDoc.appendItemValue("LogAgentStartTime", startTime);						if (errDoc != null) {				docDb = errDoc.getParentDatabase();				rtitem = logDoc.createRichTextItem("LogDocInfo");				rtitem.appendText("The document associated with this event is:");				rtitem.addNewLine(1);				rtitem.appendText("Server: " + docDb.getServer());				rtitem.addNewLine(1);				rtitem.appendText("Database: " + docDb.getFilePath());				rtitem.addNewLine(1);				rtitem.appendText("UNID: " + errDoc.getUniversalID());				rtitem.addNewLine(1);				rtitem.appendText("Note ID: " + errDoc.getNoteID());				rtitem.addNewLine(1);				rtitem.appendText("DocLink: ");				rtitem.appendDocLink(errDoc, errDoc.getUniversalID());			}						// make sure Depositor-level users can add documents too			logDoc.appendItemValue("$PublicAccess", "1");						logDoc.save(true);			retval = true;		} catch (Exception e) {			debugPrint(e);			retval = false;		} finally {			// recycle all the logDoc objects when we're done with them			try { if (rtitem != null) rtitem.recycle(); } catch (Exception e2) {}			rtitem = null;			try { if (logDoc != null) logDoc.recycle(); } catch (Exception e2) {}			logDoc = null;		}				return retval;		}		/*	 * This method decides what to do with any Exceptions that we encounter	 * internal to this class, based on the olDebugLevel variable.	 */	private void debugPrint (Exception ee) {		if ((ee == null) || (debugOut == null))			return;				try {			// debug level of 1 prints the basic error message			if (olDebugLevel >= 1) {				String debugMsg = ee.toString();				try {					if (ee instanceof NotesException) {						NotesException ne = (NotesException)ee;						debugMsg = "Notes error " + ne.id + ": " + ne.text;					}				} catch (Exception e2) {				}				debugOut.println("OpenLogItem error: " + debugMsg);			}						// debug level of 2 prints the whole stack trace			if (olDebugLevel >= 2) {				debugOut.print("OpenLogItem error trace: ");				ee.printStackTrace(debugOut);			}		} catch (Exception e) {			// at this point, if we have an error just discard it		}	}	}