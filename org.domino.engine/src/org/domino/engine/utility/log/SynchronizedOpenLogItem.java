package org.domino.engine.utility.log;import lotus.domino.Database;import lotus.domino.Document;import java.util.*;import java.io.*;import org.domino.engine.utility.log.openlog.OpenLogItem;public class SynchronizedOpenLogItem extends OpenLogItem {	/*	 * This class is functionally identical to the OpenLogItem class, with the	 * difference that all the public classes are synchronized for better thread	 * safety. I had originally synchronized most of the public methods in the	 * OpenLogItem class itself, but because there was some performance	 * overhead involved with this in the old 1.1 JVM that Notes R5 used,	 * I split it off into a separate class so you can decide whether or not you	 * want to use it. Honestly, at least 90% of the tme you probably have no	 * need for thread-safety with this class, so you can usually use the plain	 * old OpenLogItem class.	 * 	 * I realize that this is sort of a poor man's attempt at providing thread-safe	 * code, but having all of this in a separate wrapper class might help me test	 * for deadlock conditions without having to modify the original class code	 * as well.	 */	 	public synchronized Database getLogDatabase () {		return super.getLogDatabase();	}			public synchronized boolean getLogSuccess () {		return super.getLogSuccess();	}		public synchronized void initLogDb () {		super.initLogDb();	}		public synchronized String logError (Throwable ee) {		// since we're introducing another level to the logging process, we need to		//adjust the callingMethodDepth variable		callingMethodDepth = 3;		return super.logError(ee);	}		public synchronized String logErrorEx (Throwable ee, String msg, String severityType, 				Document doc) {		// since we're introducing another level to the logging process, we need to		//adjust the callingMethodDepth variable		callingMethodDepth = 3;		return super.logErrorEx(ee, msg, severityType, doc);	}		public synchronized String logEvent (String msg, String severityType, Document doc) {		// since we're introducing another level to the logging process, we need to		//adjust the callingMethodDepth variable		callingMethodDepth = 3;		return super.logEvent(msg, severityType, doc);	}		public synchronized void recycle () {		super.recycle();	}		public synchronized void resetFields () {		super.resetFields();	}		public synchronized boolean useCustomLogDb (Database customDb) {		return super.useCustomLogDb(customDb);	}	 	public synchronized boolean useDefaultLogDb () {	 	return super.useDefaultLogDb();	 }	 	public synchronized boolean writeToLog (Database db) {		return super.writeToLog(db);	}	}