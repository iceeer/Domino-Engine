package org.domino.engine.utility;import java.util.Date;public class JavaTimer {		/*	 * =======================================================	 * <HEADER>	 * NAME:	JavaTimer script library	 * VERSION:	20040214a	 * AUTHOR(S):	Julian Robichaux ( http://www.nsftools.com )	 * ORIGINAL SOURCE:	The OpenLog database, available as an	 * open-source project at http://www.OpenNTF.org	 * HISTORY:	none (this is the initial release)	 *	 * 	 *   Copyright 2004-2009, Julian Robichaux	 *	 *   Licensed under the Apache License, Version 2.0 (the "License");	 *   you may not use this file except in compliance with the License.	 *   You may obtain a copy of the License at	 *	 *       http://www.apache.org/licenses/LICENSE-2.0	 *	 *   Unless required by applicable law or agreed to in writing, software	 *   distributed under the License is distributed on an "AS IS" BASIS,	 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.	 *   See the License for the specific language governing permissions and	 *   limitations under the License.	 *	 * </HEADER>	 * =======================================================	 * 	 * This is a convenience class to easily see how long	 * your Java processes are taking to run, to the nearest	 * millisecond. Just create an instance of this class, and	 * the when you want to check to see how long it's been	 * since you created the instance, just call one of the	 * elapsedXXX methods. For example:	 * 	 * 	public String TimerTest () {	 * 		JavaTimer jt = new JavaTimer();	 * 		// do stuff...	 * 		System.out.println("That process took " + jt.elapsedMilliseconds(true) + " milliseconds");	 * 		return jt.elapsedTime(true);	 * 	}	 * 	 */	 	private long startTime;	private Date startTimeVar;	private long endTime;	private Date endTimeVar;	private boolean running = false;	private long MILLIS_PER_DAY = 1000*60*60*24;			public JavaTimer () {		this(true);	}		public JavaTimer (boolean startNow) {		if (startNow)			resetTimer();	}			public void resetTimer () {		// start the timer		startTime = System.currentTimeMillis();		startTimeVar = new Date();		running = true;	}			public void stopTimer () {		// stop the timer		endTime = System.currentTimeMillis();		endTimeVar = new Date();		running = true;	}			public boolean isRunning () {		// is the timer currently running?		return running;	}			public Date getStartTime () {		// get the date/time from when we 		// last started the timer as a Date		return startTimeVar;	}			public Date getEndTime () {		// get the date/time from when we 		// last stopped the timer as a Date		return endTimeVar;	}			public long elapsedMilliseconds (boolean stopNow) {		// how many milliseconds have elapsed since		// the timer was last reset? Using the stopNow		// parameter, you can optionally stop the timer		// if it's currently running		try {			long ntime;						if ((stopNow) && (running))				stopTimer();						if (running)				ntime = System.currentTimeMillis();			else				ntime = endTime;						return ntime - startTime;		} catch (Exception e) {			return -1;		}	}			public long elapsedSeconds (boolean stopNow) {		// how many seconds have elapsed since the timer was last reset?		return (long)(elapsedMilliseconds(stopNow) / (1000));	}			public long elapsedMinutes (boolean stopNow) {		// how many minutes have elapsed since the timer was last reset?		return (long)(elapsedMilliseconds(stopNow) / (60000));	}			public long elapsedHours (boolean stopNow) {		// how many hours have elapsed since the timer was last reset?		return (long)(elapsedMilliseconds(stopNow) / (3600000));	}			public String elapsedTime (boolean stopNow) {		// get the time elapsed as a string, in the format hh:mm:ss		long et = elapsedMilliseconds(stopNow);		return "" + (int)(et  / 3600000) + ":" + (int)((et  / 60000) % 60) + ":" + (int)((et  / 1000) % 60);	}	}